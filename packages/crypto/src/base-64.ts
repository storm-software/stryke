/* -------------------------------------------------------------------

                       âš¡ Storm Software - Stryke

 This code was released as part of the Stryke project. Stryke
 is maintained by Storm Software under the Apache-2.0 license, and is
 free for commercial and private use. For more information, please visit
 our licensing page at https://stormsoftware.com/licenses/projects/stryke.

 Website:                  https://stormsoftware.com
 Repository:               https://github.com/storm-software/stryke
 Documentation:            https://docs.stormsoftware.com/projects/stryke
 Contact:                  https://stormsoftware.com/contact

 SPDX-License-Identifier:  Apache-2.0

 ------------------------------------------------------------------- */

import { stringToUtf8Array } from "@stryke/convert/string-to-utf8-array";
import { utf8ArrayToString } from "@stryke/convert/utf8-array-to-string";
import { isString } from "@stryke/type-checks/is-string";
import { isUndefined } from "@stryke/type-checks/is-undefined";

// map 6 bits [0, 64) into ascii byte (8 bits)
// generated by
//   Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c => c.charCodeAt(0))
// biome-ignore format:
const ENCODE_MAP = new Uint8Array([
  65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,
  84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
  107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
  122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
]);

// "=".codePointAt(0)
const ENCODE_PAD = 61;

// inverse of ENCODE_MAP
// generated by
//   ENCODE_MAP.reduce((acc, v, i) => { acc[v] = i; return acc }, Array(255).fill(100))
// biome-ignore format:
const DECODE_MAP = new Uint8Array([
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 62, 100, 100,
  100, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 100, 100, 100, 100, 100, 100,
  100, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
  21, 22, 23, 24, 25, 100, 100, 100, 100, 100, 100, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100
]);

/**
 * Encodes a Uint8Array into a Base64 encoded Uint8Array.
 *
 * @credits https://github.com/hi-ogawa/js-utils
 *
 * @param input - The input Uint8Array or string to encode.
 * @returns The Base64 encoded Uint8Array.
 */
export function encodeBase64(input: Uint8Array | string): string {
  if (isString(input)) {
    input = stringToUtf8Array(input);
  }

  const xLen = input.length;
  const result = new Uint8Array(Math.ceil(xLen / 3) * 4);
  const chunkLen = Math.floor(xLen / 3);

  // encode complete chunks
  for (let i = 0; i < chunkLen; i++) {
    const chunk =
      (input[3 * i + 0]! << 16) | (input[3 * i + 1]! << 8) | input[3 * i + 2]!;
    result[4 * i + 0] = ENCODE_MAP[(chunk >> 18) & 0b111111]!;
    result[4 * i + 1] = ENCODE_MAP[(chunk >> 12) & 0b111111]!;
    result[4 * i + 2] = ENCODE_MAP[(chunk >> 6) & 0b111111]!;
    result[4 * i + 3] = ENCODE_MAP[(chunk >> 0) & 0b111111]!;
  }

  // encode partial chunk with padding
  const i = chunkLen;
  switch (xLen % 3) {
    case 1: {
      const chunk = input[3 * i + 0]! << 16;
      result[4 * i + 0] = ENCODE_MAP[(chunk >> 18) & 0b111111]!;
      result[4 * i + 1] = ENCODE_MAP[(chunk >> 12) & 0b111111]!;
      result[4 * i + 2] = ENCODE_PAD;
      result[4 * i + 3] = ENCODE_PAD;
      break;
    }
    case 2: {
      const chunk = (input[3 * i + 0]! << 16) | (input[3 * i + 1]! << 8);
      result[4 * i + 0] = ENCODE_MAP[(chunk >> 18) & 0b111111]!;
      result[4 * i + 1] = ENCODE_MAP[(chunk >> 12) & 0b111111]!;
      result[4 * i + 2] = ENCODE_MAP[(chunk >> 6) & 0b111111]!;
      result[4 * i + 3] = ENCODE_PAD;
      break;
    }
  }

  return utf8ArrayToString(result);
}

/**
 * Decodes a Base64 encoded Uint8Array into a Uint8Array.
 *
 * @credits https://github.com/hi-ogawa/js-utils
 *
 * @param input - The Base64 encoded Uint8Array or string to decode.
 * @returns The decoded Uint8Array.
 */
export function decodeBase64(input: Uint8Array | string): Uint8Array {
  if (isString(input)) {
    input = stringToUtf8Array(input);
  }

  const yLen = input.length;

  // validate length
  if (yLen % 4 !== 0) {
    throw new Error("invalid length");
  }

  // get padding length
  let padLen = 0;
  while (
    padLen < 2 &&
    padLen < input.length &&
    input[input.length - 1 - padLen] === ENCODE_PAD
  ) {
    padLen++;
  }

  // validate encoding
  for (let i = 0; i < input.length - padLen; i++) {
    if (
      isUndefined(input[i]) ||
      isUndefined(DECODE_MAP[input[i]!]) ||
      DECODE_MAP[input[i]!]! >= 64
    ) {
      throw new Error("invalid data");
    }
  }

  // validate encoding
  const chunkLen = Math.floor((yLen - padLen) / 4);
  const xLen = 3 * chunkLen + ((3 - padLen) % 3);
  const result = new Uint8Array(xLen);

  // decode complete chunks
  for (let i = 0; i < chunkLen; i++) {
    const chunk =
      (DECODE_MAP[input[4 * i + 0]!]! << 18) |
      (DECODE_MAP[input[4 * i + 1]!]! << 12) |
      (DECODE_MAP[input[4 * i + 2]!]! << 6) |
      (DECODE_MAP[input[4 * i + 3]!]! << 0);
    result[3 * i] = (chunk >> 16) & 0xff;
    result[3 * i + 1] = (chunk >> 8) & 0xff;
    result[3 * i + 2] = (chunk >> 0) & 0xff;
  }

  // decode partial chunk
  const i = chunkLen;
  switch (xLen % 3) {
    case 1: {
      const chunk =
        (DECODE_MAP[input[4 * i + 0]!]! << 18) |
        (DECODE_MAP[input[4 * i + 1]!]! << 12);
      result[3 * i] = (chunk >> 16) & 0xff;
      break;
    }
    case 2: {
      const chunk =
        (DECODE_MAP[input[4 * i + 0]!]! << 18) |
        (DECODE_MAP[input[4 * i + 1]!]! << 12) |
        (DECODE_MAP[input[4 * i + 2]!]! << 6);
      result[3 * i] = (chunk >> 16) & 0xff;
      result[3 * i + 1] = (chunk >> 8) & 0xff;
      break;
    }
  }

  return result;
}

/**
 * Converts a Base64 encoded string to a [Base64url](https://datatracker.ietf.org/doc/html/rfc7515#appendix-C) encoded string.
 *
 * @see https://datatracker.ietf.org/doc/html/rfc7515#appendix-C
 *
 * @param base64 - The Base64 encoded string to convert.
 * @returns The Base64url encoded string.
 */
export function base64ToBase64url(base64: string): string {
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

/**
 * Converts a [Base64url](https://datatracker.ietf.org/doc/html/rfc7515#appendix-C) encoded string to a Base64 encoded string.
 *
 * @see https://datatracker.ietf.org/doc/html/rfc7515#appendix-C
 *
 * @param base64url - The Base64url encoded string to convert.
 * @returns The Base64 encoded string.
 */
export function base64FromBase64url(base64url: string): string {
  return (
    base64url.replace(/-/g, "+").replace(/_/g, "/") +
    "=".repeat((4 - (base64url.length % 4)) % 4)
  );
}
